This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-16T22:39:03.299Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
routers/
  auth.py
  posts.py
  users.py
database.py
main.py
models.py

================================================================
Repository Files
================================================================

================
File: routers/auth.py
================
from datetime import datetime, timedelta, timezone
from typing import Annotated

from database import SessionLocal
from fastapi import APIRouter, Depends, HTTPException
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from jose import JWTError, jwt
from models import Users
from passlib.context import CryptContext
from pydantic import BaseModel
from sqlalchemy.orm import Session
from starlette import status

router = APIRouter(prefix="/auth", tags=["auth"])
bcrypt_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
oauth2_bearer = OAuth2PasswordBearer(tokenUrl="auth/token")


class CreateUserRequest(BaseModel):
    username: str
    email: str
    first_name: str
    last_name: str
    password: str


class Token(BaseModel):
    access_token: str
    token_type: str


def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


db_dependency = Annotated[Session, Depends(get_db)]

SECRET_KEY = "47b3d4237a7a0e498af5ac89abfbb46c0351054886d73b55a68d7c52e44a4edb"
ALGORITHM = "HS256"


def authenticate_user(username: str, password: str, db):
    user = db.query(Users).filter(Users.username == username).first()
    if not user:
        return False
    if not bcrypt_context.verify(password, user.hashed_password):
        return False
    return user


def create_access_token(username: str, user_id: int, expires_delta: timedelta):
    encode = {"sub": username, "id": user_id}
    expires = datetime.now(timezone.utc) + expires_delta
    encode.update({"exp": expires})
    return jwt.encode(encode, SECRET_KEY, algorithm=ALGORITHM)


async def get_current_user(token: Annotated[str, Depends(oauth2_bearer)]):
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        user_id: int = payload.get("id")
        if username is None or user_id is None:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Could not validate user.",
            )
        return {"username": username, "id": user_id}
    except JWTError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED, detail="Could not validate user."
        )


@router.post("/", status_code=status.HTTP_201_CREATED)
async def create_user(db: db_dependency, create_user_request: CreateUserRequest):
    create_user_model = Users(
        email=create_user_request.email,
        username=create_user_request.username,
        first_name=create_user_request.first_name,
        last_name=create_user_request.last_name,
        hashed_password=bcrypt_context.hash(create_user_request.password),
    )
    db.add(create_user_model)
    db.commit()


@router.post("/token", response_model=Token)
async def login_for_access_token(
    form_data: Annotated[OAuth2PasswordRequestForm, Depends()], db: db_dependency
):
    user = authenticate_user(form_data.username, form_data.password, db)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate user.",
        )
    token = create_access_token(user.username, user.id, timedelta(minutes=20))
    return {"access_token": token, "token_type": "bearer"}

================
File: routers/posts.py
================
from typing import Annotated

from database import SessionLocal
from fastapi import APIRouter, Depends, HTTPException, status
from models import Posts, Users
from pydantic import BaseModel
from routers.auth import get_current_user
from sqlalchemy.orm import Session

router = APIRouter(prefix="/posts", tags=["posts"])


def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


class PostRequest(BaseModel):
    content: str


db_dependency = Annotated[Session, Depends(get_db)]
user_dependency = Annotated[dict, Depends(get_current_user)]


@router.get("/", status_code=status.HTTP_200_OK)
async def get_user_posts(user: user_dependency, db: db_dependency):
    if user is None:
        raise HTTPException(status=404, detail="User Not Found.")
    return db.query(Posts).filter(Posts.owner_id == user.get("id")).all()


@router.post("/create", status_code=status.HTTP_201_CREATED)
async def create_post(user: user_dependency, db: db_dependency, new_post: PostRequest):
    if user is None:
        raise HTTPException(status=404, detail="User Not Found.")
    post_model = Posts(
        **new_post.model_dump(), username=user.get("username"), owner_id=user.get("id")
    )
    db.add(post_model)
    db.commit()


@router.delete("/remove/{post_id}", status_code=status.HTTP_204_NO_CONTENT)
async def remove_post(user: user_dependency, db: db_dependency, post_id: int):
    if user is None:
        raise HTTPException(status=404, detail="User Not Found.")
    db.query(Posts).filter(Posts.id == post_id).filter(
        Posts.owner_id == user.get("id")
    ).delete()
    db.commit()


@router.put("like/{post_id}", status_code=status.HTTP_204_NO_CONTENT)
async def like_post(user: user_dependency, db: db_dependency, post_id: int):
    if user is None:
        raise HTTPException(status=404, detail="User Not Found.")
    post_to_like = db.query(Posts).filter(Posts.id == post_id).first()
    post_to_like.likes += 1
    db.commit()

================
File: routers/users.py
================
from typing import Annotated

from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session

from app.database import SessionLocal
from app.routers.auth import get_current_user

router = APIRouter(prefix="/users", tags=["users"])


def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


db_dependency = Annotated[Session, Depends(get_db)]
user_dependency = Annotated[dict, Depends(get_current_user)]

================
File: database.py
================
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

SQLALCHEMY_DATABASE_URL = "sqlite:///./fastsocialdb.db"

engine = create_engine(
    SQLALCHEMY_DATABASE_URL, connect_args={"check_same_thread": False}
)

SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()

================
File: main.py
================
import models
from database import engine
from fastapi import FastAPI
from routers import auth, posts

app = FastAPI()

models.Base.metadata.create_all(bind=engine)
app.include_router(auth.router)
app.include_router(posts.router)

================
File: models.py
================
# Social Media APP
#
#
# User profiles and relationships (follow/unfollow)
# Post creation with media support
# Feed generation
# Direct messaging
# Notifications system
# Hashtag functionality


from database import Base
from sqlalchemy import Column, ForeignKey, Integer, String


class Users(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    username = Column(String)

    first_name = Column(String)
    last_name = Column(String)
    followers = Column(Integer)
    following = Column(Integer)
    email = Column(String)
    hashed_password = Column(String)


class Posts(Base):
    __tablename__ = "posts"

    id = Column(Integer, primary_key=True, index=True)
    username = Column(String)
    content = Column(String)
    owner_id = Column(Integer, ForeignKey("users.id"))
    # TODO: Figure out how to handle likes
    likes = Column(Integer, default=0)
